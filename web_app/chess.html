<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5f5;
            margin: 0;
            padding: 20px;
        }

        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            gap: 2px;
            margin: 20px 0;
        }

        .square {
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            cursor: pointer;
            user-select: none;
        }

        .light {
            background-color: #f0d9b5;
        }

        .dark {
            background-color: #b58863;
        }

        .selected {
            background-color: #7dd3fc !important;
        }

        .possible-move {
            background-color: #86efac !important;
        }

        .capture {
            background-color: #fca5a5 !important;
        }

        .game-info {
            margin-bottom: 20px;
            text-align: center;
        }

        .controls {
            margin-top: 20px;
        }

        button {
            padding: 10px 20px;
            margin: 0 10px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="game-info">
        <h2 id="game-status">Chess Game</h2>
        <p id="current-player">White's turn</p>
    </div>

    <div class="chess-board" id="board"></div>

    <div class="controls">
        <button id="resign-btn">Resign</button>
        <button id="draw-btn">Offer Draw</button>
    </div>

    <script>
        const botToken = '6734058764:AAGUJLRLoingzHwOngjfUngliE7k_qiwXGw';
        const chatId = new URLSearchParams(window.location.search).get('chat_id');
        const gameId = new URLSearchParams(window.location.search).get('game_id');

        let selectedPiece = null;
        let currentPlayer = 'white';
        let board = [];

        // Initialize the board
        function initBoard() {
            board = Array(8).fill(null).map(() => Array(8).fill(null));

            // Set up pawns
            for (let i = 0; i < 8; i++) {
                board[1][i] = { type: 'pawn', color: 'black' };
                board[6][i] = { type: 'pawn', color: 'white' };
            }

            // Set up other pieces
            const pieces = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];

            for (let i = 0; i < 8; i++) {
                board[0][i] = { type: pieces[i], color: 'black' };
                board[7][i] = { type: pieces[i], color: 'white' };
            }

            renderBoard();
        }

        // Render the board
        function renderBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;

                    // Add piece if exists
                    const piece = board[row][col];
                    if (piece) {
                        square.textContent = getPieceSymbol(piece);
                    }

                    // Add selected class
                    if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                        square.classList.add('selected');
                    }

                    square.addEventListener('click', () => handleSquareClick(row, col));
                    boardElement.appendChild(square);
                }
            }

            // Update game status
            document.getElementById('current-player').textContent =
                `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s turn`;
        }

        // Get Unicode symbol for piece
        function getPieceSymbol(piece) {
            const symbols = {
                white: {
                    king: '♔',
                    queen: '♕',
                    rook: '♖',
                    bishop: '♗',
                    knight: '♘',
                    pawn: '♙'
                },
                black: {
                    king: '♚',
                    queen: '♛',
                    rook: '♜',
                    bishop: '♝',
                    knight: '♞',
                    pawn: '♟'
                }
            };

            return symbols[piece.color][piece.type];
        }

        // Handle square clicks
        function handleSquareClick(row, col) {
            const piece = board[row][col];

            // If no piece is selected
            if (!selectedPiece) {
                if (piece && piece.color === currentPlayer) {
                    selectedPiece = { row, col };
                    renderBoard();
                }
                return;
            }

            // If clicking the same square, deselect
            if (selectedPiece.row === row && selectedPiece.col === col) {
                selectedPiece = null;
                renderBoard();
                return;
            }

            // If clicking another piece of the same color, select it
            if (piece && piece.color === currentPlayer) {
                selectedPiece = { row, col };
                renderBoard();
                return;
            }

            // Try to make a move
            if (isValidMove(selectedPiece.row, selectedPiece.col, row, col)) {
                makeMove(selectedPiece.row, selectedPiece.col, row, col);
            } else {
                selectedPiece = null;
                renderBoard();
            }
        }

        // Check if move is valid
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            if (!piece) return false;

            // Basic movement rules (simplified)
            if (piece.type === 'pawn') {
                const direction = piece.color === 'white' ? -1 : 1;
                const startRow = piece.color === 'white' ? 6 : 1;

                // Forward move
                if (fromCol === toCol && !board[toRow][toCol]) {
                    if (fromRow + direction === toRow) return true;
                    if (fromRow === startRow && fromRow + 2*direction === toRow && !board[fromRow + direction][fromCol]) {
                        return true;
                    }
                }

                // Capture
                if (Math.abs(fromCol - toCol) === 1 && fromRow + direction === toRow && board[toRow][toCol]) {
                    return true;
                }
            }

            // Add rules for other pieces...

            return false;
        }

        // Make a move
        function makeMove(fromRow, fromCol, toRow, toCol) {
            // Send move to bot
            sendMoveToBot(fromRow, fromCol, toRow, toCol);

            // Update local board
            board[toRow][toCol] = board[fromRow][fromCol];
            board[fromRow][fromCol] = null;

            // Switch player
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';

            selectedPiece = null;
            renderBoard();
        }

        // Send move to Telegram bot
        function sendMoveToBot(fromRow, fromCol, toRow, toCol) {
            const move = `${fromRow}${fromCol}${toRow}${toCol}`;

            fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    chat_id: chatId,
                    text: `Chess move: ${move}`,
                    reply_markup: {
                        inline_keyboard: [
                            [{ text: "View move", callback_data: `chess_move_${gameId}_${move}` }]
                        ]
                    }
                })
            });
        }

        // Initialize the game
        initBoard();

        // Button event listeners
        document.getElementById('resign-btn').addEventListener('click', () => {
            if (confirm('Are you sure you want to resign?')) {
                fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        chat_id: chatId,
                        text: `Chess resignation for game ${gameId}`
                    })
                });

                alert('You have resigned the game.');
            }
        });

        document.getElementById('draw-btn').addEventListener('click', () => {
            fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    chat_id: chatId,
                    text: `Chess draw offer for game ${gameId}`
                })
            });

            alert('Draw offer sent to your opponent.');
        });
    </script>
</body>
</html>