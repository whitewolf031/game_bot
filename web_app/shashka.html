<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shashka (Russian Checkers)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5f5;
            margin: 0;
            padding: 20px;
        }

        .shashka-board {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            gap: 1px;
            margin: 20px 0;
            border: 2px solid #333;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }

        .square {
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            position: relative;
        }

        .light {
            background-color: #f0d9b5;
        }

        .dark {
            background-color: #b58863;
        }

        .selected {
            background-color: #7dd3fc !important;
        }

        .possible-move {
            background-color: #86efac !important;
        }

        .capture {
            background-color: #fca5a5 !important;
        }

        .piece {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .white-piece {
            background-color: #fff;
            color: #d00;
        }

        .black-piece {
            background-color: #333;
            color: #fff;
        }

        .king {
            border: 2px solid gold;
        }

        .game-info {
            margin-bottom: 20px;
            text-align: center;
            max-width: 400px;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
        }

        #resign-btn {
            background-color: #f87171;
            color: white;
        }

        #draw-btn {
            background-color: #60a5fa;
            color: white;
        }

        #status {
            margin-top: 10px;
            font-weight: bold;
            padding: 10px;
            border-radius: 5px;
            background-color: #e2e8f0;
        }

        .coordinates {
            position: absolute;
            font-size: 10px;
            color: rgba(0,0,0,0.5);
        }

        .top-coord {
            top: 2px;
            left: 2px;
        }

        .side-coord {
            bottom: 2px;
            right: 2px;
        }
    </style>
</head>
<body>
    <div class="game-info">
        <h2>Shashka (Russian Checkers)</h2>
        <div id="status">Loading game...</div>
    </div>

    <div class="shashka-board" id="board"></div>

    <div class="controls">
        <button id="resign-btn">Resign</button>
        <button id="draw-btn">Offer Draw</button>
    </div>

    <script>
        // Get parameters from URL
        const urlParams = new URLSearchParams(window.location.search);
        const gameId = urlParams.get('game_id');
        const playerId = urlParams.get('player_id');

        // Game state
        let currentPlayerColor = null;
        let gameStatus = 'loading';
        let selectedPiece = null;
        let possibleMoves = [];
        let boardState = Array(8).fill(null).map(() => Array(8).fill(null));

        // Initialize the game
        async function initGame() {
            document.getElementById('status').textContent = "Loading game data...";

            try {
                initializeBoard();

                // Determine player color (in a real app, this would come from the server)
                currentPlayerColor = playerId.endsWith('1') ? 'white' : 'black';

                document.getElementById('status').textContent =
                    `You are playing as ${currentPlayerColor === 'white' ? 'white (🔴)' : 'black (⚪)'}. ${currentPlayerColor === 'white' ? 'Your turn!' : 'Waiting for opponent...'}`;

                gameStatus = 'active';

            } catch (error) {
                document.getElementById('status').textContent = "Error loading game: " + error.message;
                console.error(error);
            }
        }

        // Initialize the shashka board
        function initializeBoard() {
            // Clear the board
            boardState = Array(8).fill(null).map(() => Array(8).fill(null));

            // Set up initial pieces (Russian checkers setup)
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    // Only place pieces on dark squares
                    if ((row + col) % 2 !== 0) {
                        // White pieces (🔴)
                        if (row < 3) {
                            boardState[row][col] = { type: 'piece', color: 'white', isKing: false };
                        }
                        // Black pieces (⚪)
                        else if (row > 4) {
                            boardState[row][col] = { type: 'piece', color: 'black', isKing: false };
                        }
                    }
                }
            }

            renderBoard();
        }

        // Render the board
        function renderBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;

                    // Add coordinates
                    if (col === 0) {
                        const rowCoord = document.createElement('div');
                        rowCoord.className = 'coordinates side-coord';
                        rowCoord.textContent = 8 - row;
                        square.appendChild(rowCoord);
                    }

                    if (row === 7) {
                        const colCoord = document.createElement('div');
                        colCoord.className = 'coordinates top-coord';
                        colCoord.textContent = String.fromCharCode(97 + col);
                        square.appendChild(colCoord);
                    }

                    // Add piece if exists
                    const piece = boardState[row][col];
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = `piece ${piece.color}-piece ${piece.isKing ? 'king' : ''}`;
                        pieceElement.textContent = piece.color === 'white' ? '🔴' : '⚪';
                        square.appendChild(pieceElement);
                    }

                    // Add selected class
                    if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                        square.classList.add('selected');
                    }

                    // Add possible move indicators
                    const isPossibleMove = possibleMoves.some(move =>
                        move.toRow === row && move.toCol === col
                    );

                    if (isPossibleMove) {
                        const move = possibleMoves.find(m => m.toRow === row && m.toCol === col);
                        if (move.captures && move.captures.length > 0) {
                            square.classList.add('capture');
                        } else {
                            square.classList.add('possible-move');
                        }
                    }

                    square.addEventListener('click', () => handleSquareClick(row, col));
                    boardElement.appendChild(square);
                }
            }
        }

        // Handle square clicks
        function handleSquareClick(row, col) {
            if (gameStatus !== 'active') return;

            const piece = boardState[row][col];

            // If no piece is selected
            if (!selectedPiece) {
                if (piece && piece.color === currentPlayerColor) {
                    selectedPiece = { row, col };
                    calculatePossibleMoves(row, col);
                    renderBoard();
                }
                return;
            }

            // If clicking the same square, deselect
            if (selectedPiece.row === row && selectedPiece.col === col) {
                selectedPiece = null;
                possibleMoves = [];
                renderBoard();
                return;
            }

            // If clicking another piece of the same color, select it
            if (piece && piece.color === currentPlayerColor) {
                selectedPiece = { row, col };
                calculatePossibleMoves(row, col);
                renderBoard();
                return;
            }

            // Check if this is a valid move
            const move = possibleMoves.find(m =>
                m.toRow === row && m.toCol === col
            );

            if (move) {
                makeMove(selectedPiece.row, selectedPiece.col, row, col, move.captures);
            } else {
                selectedPiece = null;
                possibleMoves = [];
                renderBoard();
            }
        }

        // Calculate possible moves for a piece
        function calculatePossibleMoves(fromRow, fromCol) {
            possibleMoves = [];
            const piece = boardState[fromRow][fromCol];
            if (!piece) return;

            const direction = piece.color === 'white' ? 1 : -1;

            // Regular pieces can only move forward (unless they're kings)
            if (!piece.isKing) {
                // Check simple moves
                checkShashkaMove(fromRow, fromCol, fromRow + direction, fromCol - 1, piece.color, []);
                checkShashkaMove(fromRow, fromCol, fromRow + direction, fromCol + 1, piece.color, []);

                // Check captures
                checkShashkaCapture(fromRow, fromCol, piece.color, []);
            }
            // Kings can move in all directions
            else {
                // Check all 4 diagonal directions
                for (let rowDir of [-1, 1]) {
                    for (let colDir of [-1, 1]) {
                        checkShashkaMove(fromRow, fromCol, fromRow + rowDir, fromCol + colDir, piece.color, []);
                        checkShashkaCaptureKing(fromRow, fromCol, rowDir, colDir, piece.color, []);
                    }
                }
            }
        }

        // Check if a simple move is possible
        function checkShashkaMove(fromRow, fromCol, toRow, toCol, color, captures) {
            // Check if move is within board bounds
            if (toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) return false;

            // Check if target square is empty and on a dark square
            if (boardState[toRow][toCol] || (toRow + toCol) % 2 === 0) return false;

            // For non-capturing moves, only allow if no captures are available
            if (captures.length === 0) {
                possibleMoves.push({
                    fromRow, fromCol, toRow, toCol, captures
                });
                return true;
            }

            return false;
        }

        // Check for possible captures (for regular pieces)
        function checkShashkaCapture(fromRow, fromCol, color, visited) {
            let foundCapture = false;
            const directions = [
                {row: 1, col: -1},  // down-left
                {row: 1, col: 1},    // down-right
                {row: -1, col: -1},  // up-left
                {row: -1, col: 1}    // up-right
            ];

            for (const dir of directions) {
                const jumpRow = fromRow + dir.row;
                const jumpCol = fromCol + dir.col;
                const landRow = fromRow + 2 * dir.row;
                const landCol = fromCol + 2 * dir.col;

                // Check if jump is within bounds
                if (landRow < 0 || landRow > 7 || landCol < 0 || landCol > 7) continue;

                // Check if landing square is empty and dark
                if (boardState[landRow][landCol] || (landRow + landCol) % 2 === 0) continue;

                // Check if there's an opponent piece to jump over
                const jumpedPiece = boardState[jumpRow][jumpCol];
                if (!jumpedPiece || jumpedPiece.color === color) continue;

                // Check if we've already captured this piece
                if (visited.some(pos => pos.row === jumpRow && pos.col === jumpCol)) continue;

                // This is a valid capture
                const newVisited = [...visited, {row: jumpRow, col: jumpCol}];

                // Check for multi-captures
                const hasFurtherCaptures = checkShashkaCapture(landRow, landCol, color, newVisited);

                if (!hasFurtherCaptures) {
                    possibleMoves.push({
                        fromRow, fromCol,
                        toRow: landRow, toCol: landCol,
                        captures: newVisited
                    });
                }

                foundCapture = true;
            }

            return foundCapture;
        }

        // Check for possible captures (for kings)
        function checkShashkaCaptureKing(fromRow, fromCol, rowDir, colDir, color, visited) {
            let foundCapture = false;
            let jumpedPiecePos = null;

            // Look along the diagonal for opponent pieces
            for (let distance = 1; distance < 8; distance++) {
                const checkRow = fromRow + distance * rowDir;
                const checkCol = fromCol + distance * colDir;

                // Stop if we go out of bounds
                if (checkRow < 0 || checkRow > 7 || checkCol < 0 || checkCol > 7) break;

                // Skip light squares
                if ((checkRow + checkCol) % 2 === 0) continue;

                const piece = boardState[checkRow][checkCol];

                // If we find an empty square after a capture opportunity
                if (!piece && jumpedPiecePos) {
                    // Check if we've already captured this piece
                    if (visited.some(pos => pos.row === jumpedPiecePos.row && pos.col === jumpedPiecePos.col)) {
                        break;
                    }

                    const newVisited = [...visited, jumpedPiecePos];

                    // Check for multi-captures
                    const hasFurtherCaptures = checkShashkaCaptureKing(
                        checkRow, checkCol, rowDir, colDir, color, newVisited
                    );

                    if (!hasFurtherCaptures) {
                        possibleMoves.push({
                            fromRow, fromCol,
                            toRow: checkRow, toCol: checkCol,
                            captures: newVisited
                        });
                    }

                    foundCapture = true;
                    break;
                }

                // If we find our own piece, stop looking in this direction
                if (piece && piece.color === color) {
                    break;
                }

                // If we find an opponent piece, remember its position
                if (piece && piece.color !== color && !jumpedPiecePos) {
                    jumpedPiecePos = {row: checkRow, col: checkCol};
                }
                // If we find a second opponent piece, stop looking
                else if (piece && piece.color !== color && jumpedPiecePos) {
                    break;
                }
            }

            return foundCapture;
        }

        // Make a move
        function makeMove(fromRow, fromCol, toRow, toCol, captures) {
            // Send move to bot
            sendMoveToBot(fromRow, fromCol, toRow, toCol, captures);

            // Update local board
            const piece = boardState[fromRow][fromCol];
            boardState[fromRow][fromCol] = null;
            boardState[toRow][toCol] = piece;

            // Remove captured pieces
            if (captures && captures.length > 0) {
                for (const capture of captures) {
                    boardState[capture.row][capture.col] = null;
                }
            }

            // Check for promotion to king
            if (!piece.isKing) {
                if ((piece.color === 'white' && toRow === 7) ||
                    (piece.color === 'black' && toRow === 0)) {
                    piece.isKing = true;
                }
            }

            selectedPiece = null;
            possibleMoves = [];
            renderBoard();

            document.getElementById('status').textContent = "Move sent! Waiting for opponent...";
            gameStatus = 'waiting';
        }

        // Send move to Telegram bot
        function sendMoveToBot(fromRow, fromCol, toRow, toCol, captures) {
            let moveNotation = `${String.fromCharCode(97 + fromCol)}${8 - fromRow}-${String.fromCharCode(97 + toCol)}${8 - toRow}`;

            if (captures && captures.length > 0) {
                moveNotation = `${String.fromCharCode(97 + fromCol)}${8 - fromRow}x${String.fromCharCode(97 + toCol)}${8 - toRow}`;
            }

            // In a real implementation, you'd use Telegram Bot API to send the move
            console.log(`Sending shashka move: ${moveNotation}`);

            // This would be the actual API call:
            // fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
            //     method: 'POST',
            //     headers: {
            //         'Content-Type': 'application/json'
            //     },
            //     body: JSON.stringify({
            //         chat_id: playerId,
            //         text: `/shashka_move_${gameId}_${fromRow}${fromCol}${toRow}${toCol}`
            //     })
            // });
        }

        // Handle game end
        function endGame(winner) {
            gameStatus = 'finished';
            let message = "";

            if (winner === currentPlayerColor) {
                message = "🎉 You won the game! 10 points have been added to your account.";
            } else if (winner === 'draw') {
                message = "🤝 The game ended in a draw!";
            } else {
                message = "😢 You lost the game. Better luck next time!";
            }

            document.getElementById('status').textContent = message;

            // Disable board
            const squares = document.querySelectorAll('.square');
            squares.forEach(sq => sq.style.pointerEvents = 'none');
        }

        // Button event listeners
        document.getElementById('resign-btn').addEventListener('click', () => {
            if (confirm('Are you sure you want to resign?')) {
                // Send resignation to bot
                fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        chat_id: playerId,
                        text: `/shashka_end_${gameId}_${currentPlayerColor === 'white' ? 'black' : 'white'}`
                    })
                });

                endGame(currentPlayerColor === 'white' ? 'black' : 'white');
            }
        });

        document.getElementById('draw-btn').addEventListener('click', () => {
            if (confirm('Offer a draw to your opponent?')) {
                fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        chat_id: playerId,
                        text: `/shashka_end_${gameId}_0`  // 0 means draw
                    })
                });

                alert('Draw offer sent to your opponent.');
            }
        });

        // Initialize the game when page loads
        initGame();
    </script>
</body>
</html>